def generate_lists(grammarPath,wordPath):
    """Reads from both files and generates one list for GENERATORS (States),
        another list for PRODUCTS and one last list for WORDS, finally
        returning all said lists.

    Parameters:
        grammarPath: path for the grammar file (string), eg. "gramatica.txt".
        wordPath: path for the words file (string), eg. "palabras.txt"

    RETURNS generators (List), products (List), words (List)
    """
    grammar = open(grammarPath,"r")
    word = open(wordPath,"r")
    
    generators = []
    products = []
    words = []
    grammarCount = 0;
    wordCount = 0;
    for grammarLine in grammar:
        if grammarCount == 0:
            Ngrammars = grammarLine
        elif grammarCount > int(Ngrammars):
            break
        else:
            parsedLine = grammarLine.replace(" ","").split("->")
            generators.append(parsedLine[0])
            if(parsedLine[1][len(parsedLine[1])-1:len(parsedLine[1])] == "\n"):
                products.append(parsedLine[1][:len(parsedLine[1])-1])
            else:
                products.append(parsedLine[1])
        grammarCount+=1
        
    for wordLine in word:
        if wordCount == 0:
            Nwords = wordLine
        elif wordCount > int(Nwords):
            break
        else:
            if(wordLine[len(wordLine)-1:len(wordLine)] == "\n"):
                words.append(wordLine[:len(wordLine)-1])
            else:
                words.append(wordLine)

        wordCount+=1

    grammar.close()
    word.close()
    
    return generators,products,words

def findGenerator(generators,products,expression):
    """Finds and returns the GENERATOR list, which are all the states that lead to the given expression.

    Parameters:
        generators: a list containing all the generators (states) that were read from the grammar file.
        products: a list containing all the products that were read from the grammar file.
        expression: the expression that will be used to find and return all the states that produce it.

        RETURNS matchedGenerators (List)
    """
    matchedGenerators = []
    i = 0
    for p in products:
        if p == expression:
            matchedGenerators.append(generators[i])
        i+=1
    return matchedGenerators

def generateExpressions(l1,l2):
    """Concatenates all the possible combinations for the desired "elements"
        For example, for the elements [A,B] and [C,D,E] this function
        will return [AC,AD,AE,BC,BD,BE], it is clearly noticable that
        ORDER IS IMPORTANT, generateExpressions(l1,l2) != generateExpressions(l2,l1)

    Parameters:
        l1 = first element 
        l2 = second element

        RETURNS elements (List)
    """
    m = 0
    n = 0
    elements = []
    for symbol1 in l1:
        for symbol2 in l2:
            elements.append(str(symbol1+symbol2))
            n+=1
        m+=1
    return elements
            

def CYK(generators, products, word):
    """Performs CYK algorithm to check if a given word belongs to the language represented by
        the grammar that was read from the grammar file.
        For a better understanding of the function, check the comments provided on each important step.

    Parameters:
        generators: a list containing all the generators (states) that were read from the grammar file.
        products: a list containing all the products that were read from the grammar file.
        expression: a word (string), that will be checked with the CYK algorithm for the given grammar.

        RETURNS True/False depending on whether or not the word belongs to the language.
    """
    
    matrix = []
    matrixLine = []
    
    #-----ADD FIRST LINE (WHICH STATES CONTAIN EACH SYMBOL OF THE WORD)-----#
    for symbol in word:
        matrixLine.append(findGenerator(generators,products,symbol))
    matrix.append(matrixLine)

    #-----CYK ALGORITHM FOR THE REMAINING LINES (len(word)-1)-----#
    #This for covers all the lines 
    for j in range(len(word)-1):
        matrixLine = []
        #This for covers all the elements in each line (len(word)-currentLine-1, because its only the upper left half)
        for k in range(len(word)-j-1):
            matrixSymbol = []
            #This for covers all the possible combinations of elements on each position (currentLine + 1 combinations)
            for l in range(j+1):
                element1 = matrix[l][k]
                element2 = matrix[j-l][l+k+1]
                elements = generateExpressions(element1,element2)

                #This for checks every possible combination obtained from the concatenations
                for element in elements:
                    generator1 = findGenerator(generators,products,element)
                    #If the element is generated by any of the generators
                    if generator1:
                        #This for checks all the generators that generate the actual element
                        for generator in generator1:
                            #If the generator is not already on the selection that will be added to the current position, then add it
                            if generator not in matrixLine:
                                matrixSymbol.append(generator)

            #Append the current elements to the actual line                    
            matrixLine.append(matrixSymbol)
        #Append the completed line to the matrix
        matrix.append(matrixLine)

    i = 0
    last = []
    for line in matrix:
        #Gets the last line in the matrix (last element inserted)
        if i == len(matrix)-1:
            last = line[0]
        i+=1

    #Assuming the first Rule inserted had the INITIAL STATE:
    #If the initial state is contained in the last element, then the word belongs to the language represented by the grammar
    #If the word belongs to the language, "SI" will be printed. "NO" will be printed otherwise.
    if generators[0] in last:
        #print p
        print "SI"
        return True
    else:
        #print p
        print "NO"
        return False
            
                        
#EXAMPLE MAIN
print "CYK ALGORITHM V.1.0 (PYTHON)"
print "-------------------------------"
print "Creator: Juan Pablo Arevalo"
print "\nResults: \n"

generadores,productos,palabras = generate_lists("gramatica.txt","palabras.txt")

for p in palabras:
    CYK(generadores,productos,p)

raw_input("\nPress INTRO/ENTER to exit:")



        
            
        



